[{"content":"704. 二分查找 题目描述 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1\n做题思路 由于数组是有序的，所以可以使用二分法。首先取数组中点位置，比较后确定目标值所在区间是左区间还是右区间，随后再取子区间的中点，不断二分，直到定位目标值\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int search(int[] nums, int target) { int left=0;//初始左端 int right=nums.length-1;//初始右端 while(left\u0026lt;=right){//不断二分 int middle=(left+right)/2; if(nums[middle]\u0026gt;target)right=middle-1;//左区间 else if(nums[middle]\u0026lt;target)left=middle+1;//右区间 else {return middle;} } return -1; } } 27. 移除元素 题目描述 给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n做题思路 由于不需要考虑数组中超出新长度后面的元素，所以可以考虑使用双指针法。首先快慢指针初始化 0，快指针前进，若指向元素不是 val，那么就修改慢指针指向元素为快指针元素，同时慢指针前进；若指向元素是 val，则跳过，继续前进，慢指针不动。\n如此做，就可以跳过所有 val 元素，将所有非 val 元素挪到前面。最后运行结束，此时慢指针的位置就是所有非 val 元素的数量。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int removeElement(int[] nums, int val) { int slowindex=0;//慢指针 for(int fastindex=0;fastindex\u0026lt;nums.length;fastindex++){ if(nums[fastindex]!=val){ nums[slowindex]=nums[fastindex];//慢指针元素替换 slowindex++;//慢指针移动 } } return slowindex;//因为替换完最后一个非val元素后慢指针又+1，所以下标就是数量 } } ","date":"2023-01-29T00:00:00Z","image":"https://ryanzuu.github.io/myblog/lc.webp","permalink":"https://ryanzuu.github.io/myblog/p/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B001704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","title":"【LeetCode刷题笔记01】704.二分查找 27.移除元素"},{"content":"977. 有序数组的平方 题目描述 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n做题思路 由于原数组存在负数，所以平方后最大值可能出现在两端。因此可以采用双指针法，在数组首尾各放置一个指针，比较指针元素平方后的值。较大者放入结果数组末端，同时该指针向中间移动，继续比较。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int[] sortedSquares(int[] nums) { int left=0;//左指针 int right=nums.length-1;//右指针 int[] result=new int[nums.length];//结果数组 int index=result.length-1;//结果数组的指针要放在末端 while(left\u0026lt;=right){//注意等号 if(nums[left]*nums[left]\u0026gt;nums[right]*nums[right]){//左指针元素平方比右指针大 result[index--]=nums[left]*nums[left];//左指针元素平方放入结果数组 ++left;//左指针移动 } else{ result[index--]=nums[right]*nums[right];//右指针元素平方放入结果数组 --right;//右指针移动 } } return result; } } 209. 长度最小的子数组 题目描述 给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。\n做题思路 由于本题的目标是连续子数组，所以可以想到使用滑动窗口法，也就是双指针法。\n将右指针设定为子数组的右端，左指针为左端。首先左指针不动，右指针右移，滑动窗口不断增长，和不断增加，当和 ≥ target 时，此时的长度满足条件，但题目要求长度最小，因此需要与之前成立的长度进行比较，更新最小长度。同时左指针右移，更新滑动窗口。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int minSubArrayLen(int target, int[] nums) { int left=0;//左指针 int result=Integer.MAX_VALUE; int sum=0; for(int right=0;right\u0026lt;nums.length;right++){//左指针不动，右指针右移，构建窗口 sum+=nums[right]; while(sum\u0026gt;=target){//此时窗口内的和已经满足条件 result=Math.min(result,right-left+1);//更新最小长度 sum-=nums[left++];//左指针右移，开始新一轮窗口 } } return result==Integer.MAX_VALUE?0:result; } } 59. 螺旋矩阵 II 题目描述 给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n做题思路 本题的关键点是区间左右的开闭和n 奇偶的分别处理，将一圈分为上下左右 4 个左开右闭的区间。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //采取左闭右开区间 class Solution { public int[][] generateMatrix(int n) { int loop=0;//循环数 int[][] res=new int [n][n]; int start=0;//每次循环从(start,start)开始 int count=1;//填入的数 int i,j; while(loop++\u0026lt;n/2){//注意没有等号，因为第1圈是第0次循环 for(j=start;j\u0026lt;n-loop;j++){ res[start][j]=count++;//上面从左到右 } for(i=start;i\u0026lt;n-loop;i++){ res[i][j]=count++;//右边从上到下 } for(;j\u0026gt;=loop;j--){ res[i][j]=count++;//下面从右到左 } for(;i\u0026gt;=loop;i--){ res[i][j]=count++;//左边从下到上 } start++; } if(n%2==1){//如果n是奇数，中心要单独赋值 res[n/2][n/2]=count; } return res; } } ","date":"2023-01-29T00:00:00Z","image":"https://ryanzuu.github.io/myblog/lc.webp","permalink":"https://ryanzuu.github.io/myblog/p/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B002977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-59.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5ii/","title":"【Leetcode刷题笔记02】977.有序数组的平方 209.长度最小的子数组 59.螺旋矩阵II"},{"content":"Go 语言简介 什么是 Go 语言 高性能、高并发 语法简单、学习曲线平缓 丰富的标准库 完善的工具链 静态链接 快速编译 跨平台 垃圾回收 哪些公司在使用 Go 语言 首先字节跳动已经全面拥抱了 Go 语言，公司内部有上万个微服务使用 Golang 来编写，不久前也开源了 GO RPC 框架 KiteX\n根据拉勾的招聘数据，腾讯、百度、美团、滴滴、深信服、平安、OPPO、知乎、去哪儿、360、金山、微博、哔哩哔哩、七牛、PingCAP 等公司也在大量使用 Go 语言\n从业务维度看 Go 语言已经在云计算、微服务、大数据、区块链、物联网等领域蓬勃发展，在云计算、微服务等领域已经有非常高的市场占有率，Docker、Kubernetes、Istio、etcd、prometheus 几乎所有的云原生组件全是用 Go 实现的\n基础语法 hello world 1 2 3 4 5 6 7 8 9 package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;hello world\u0026#34;) } package main 表示该文件属于 main 包的一部分，main 包就是程序的入口包\nimport 语句表示导入了标准库里面的 fmt 包，该包的主要作用是往屏幕输入输出字符串、格式化字符串\nmain 函数里调用 fmt. Println 输出 hello world\n变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { var a = \u0026#34;initial\u0026#34; var b, c int = 1, 2 var d = true var e float64 f := float32(e) g := a + \u0026#34;foo\u0026#34; fmt.Println(a, b, c, d, e, f) // initial 1 2 true 0 0 fmt.Println(g) // initialapple const s string = \u0026#34;constant\u0026#34; const h = 500000000 const i = 3e20 / h fmt.Println(s, h, i, math.Sin(h), math.Sin(i)) } Go 语言中的变量声明有两种方式，一种类似于 C++的 auto 关键字，通过形如 var a = \u0026quot;initial\u0026quot; 的方式声明，这种方式下会自动推导变量类型。当然也可以在变量名后显式的写出变量类型，如 var b, c int = 1, 2。另一种声明变量的方式是使用 变量 := 值\nGo 语言中的常量使用 const 关键字\nif else 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import \u0026#34;fmt\u0026#34; func main() { if 7%2 == 0 { fmt.Println(\u0026#34;7 is even\u0026#34;) } else { fmt.Println(\u0026#34;7 is odd\u0026#34;) } if 8%4 == 0 { fmt.Println(\u0026#34;8 is divisible by 4\u0026#34;) } if num := 9; num \u0026lt; 0 { fmt.Println(num, \u0026#34;is negative\u0026#34;) } else if num \u0026lt; 10 { fmt.Println(num, \u0026#34;has 1 digit\u0026#34;) } else { fmt.Println(num, \u0026#34;has multiple digits\u0026#34;) } } Go 中的 if else 与 C++类似，不同点在于 if 后的条件不加括号，且 if else 的大括号必须加上\n循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { i := 1 for { fmt.Println(\u0026#34;loop\u0026#34;) break } for j := 7; j \u0026lt; 9; j++ { fmt.Println(j) } for n := 0; n \u0026lt; 5; n++ { if n%2 == 0 { continue } fmt.Println(n) } for i \u0026lt;= 3 { fmt.Println(i) i = i + 1 } } for 循环后什么都不加等于一个 while (true) 的死循环\nfor 后面不加括号\nswitch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { a := 2 switch a { case 1: fmt.Println(\u0026#34;one\u0026#34;) case 2: fmt.Println(\u0026#34;two\u0026#34;) case 3: fmt.Println(\u0026#34;three\u0026#34;) case 4, 5: fmt.Println(\u0026#34;four or five\u0026#34;) default: fmt.Println(\u0026#34;other\u0026#34;) } t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;It\u0026#39;s before noon\u0026#34;) default: fmt.Println(\u0026#34;It\u0026#39;s after noon\u0026#34;) } } switch 的用法类似于 C++，不同点在于每一个 case 后不用加 break 语句也会自动跳出。而且 case 条件也可以多种多样，类似一个 if else 的组合\n数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func main() { var a [5]int a[4] = 100 fmt.Println(\u0026#34;get:\u0026#34;, a[2]) fmt.Println(\u0026#34;len:\u0026#34;, len(a)) b := [5]int{1, 2, 3, 4, 5} fmt.Println(b) var twoD [2][3]int for i := 0; i \u0026lt; 2; i++ { for j := 0; j \u0026lt; 3; j++ { twoD[i][j] = i + j } } fmt.Println(\u0026#34;2d: \u0026#34;, twoD) } Go 中的数组类似于 C++ 中的数组，具有固定的长度。值得注意的是，Go 中的数据类型是后置的，不管是声明变量还是声明数组\n切片 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { s := make([]string, 3) s[0] = \u0026#34;a\u0026#34; s[1] = \u0026#34;b\u0026#34; s[2] = \u0026#34;c\u0026#34; fmt.Println(\u0026#34;get:\u0026#34;, s[2]) // c fmt.Println(\u0026#34;len:\u0026#34;, len(s)) // 3 s = append(s, \u0026#34;d\u0026#34;) s = append(s, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;) fmt.Println(s) // [a b c d e f] c := make([]string, len(s)) copy(c, s) fmt.Println(c) // [a b c d e f] fmt.Println(s[2:5]) // [c d e] fmt.Println(s[:5]) // [a b c d e] fmt.Println(s[2:]) // [c d e f] good := []string{\u0026#34;g\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;d\u0026#34;} fmt.Println(good) // [g o o d] } 类似于 C++中的 vector 容器，使用 make 关键字声明切片，括号内为切片内元素的数据类型和切片的初始长度。使用 append 方法来想切片中添加元素，使用 copy 方法拷贝切片内容到新切片\nmap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func main() { m := make(map[string]int) m[\u0026#34;one\u0026#34;] = 1 m[\u0026#34;two\u0026#34;] = 2 fmt.Println(m) // map[one:1 two:2] fmt.Println(len(m)) // 2 fmt.Println(m[\u0026#34;one\u0026#34;]) // 1 fmt.Println(m[\u0026#34;unknow\u0026#34;]) // 0 r, ok := m[\u0026#34;unknow\u0026#34;] fmt.Println(r, ok) // 0 false delete(m, \u0026#34;one\u0026#34;) m2 := map[string]int{\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2} var m3 = map[string]int{\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2} fmt.Println(m2, m3) } 类似于 C++中的 map，如 map[string]int，其中 string 为 key 类型，int 为 value 类型\nrange 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import \u0026#34;fmt\u0026#34; func main() { nums := []int{2, 3, 4} sum := 0 for i, num := range nums { sum += num if num == 2 { fmt.Println(\u0026#34;index:\u0026#34;, i, \u0026#34;num:\u0026#34;, num) // index: 0 num: 2 } } fmt.Println(sum) // 9 m := map[string]string{\u0026#34;a\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;B\u0026#34;} for k, v := range m { fmt.Println(k, v) // b 8; a A } for k := range m { fmt.Println(\u0026#34;key\u0026#34;, k) // key a; key b } } 类似于 Python 中的 range，对于一个 slice 或 map，我们可以用 range 来快速遍历，使代码更加简洁\nrange 遍历时，对于数组会返回两个值，第一个是索引，第二个是对应位置的值，如果不需要索引，可以用下划线来忽略\n函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import \u0026#34;fmt\u0026#34; func add(a int, b int) int { return a + b } func add2(a, b int) int { return a + b } func exists(m map[string]string, k string) (v string, ok bool) { v, ok = m[k] return v, ok } func main() { res := add(1, 2) fmt.Println(res) // 3 v, ok := exists(map[string]string{\u0026#34;a\u0026#34;: \u0026#34;A\u0026#34;}, \u0026#34;a\u0026#34;) fmt.Println(v, ok) // A True } Go 原生支持函数返回多个值，在实际的业务逻辑代码中很多情况下都返回两个值，第一个是真正的返回结果，第二个是错误信息\n指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import \u0026#34;fmt\u0026#34; func add2(n int) { n += 2 } func add2ptr(n *int) { *n += 2 } func main() { n := 5 add2(n) fmt.Println(n) // 5 add2ptr(\u0026amp;n) fmt.Println(n) // 7 } Go 语言也支持指针，但 Go 语言的指针支持的操作很有限，一个主要用途就是对传入的参数进行修改。\n来看这个 add 函数，这个函数试图把一个变量+2，但是单纯像上面这种写法是无效的，因为传入函数的参数实际上是一个拷贝。那也说这个+2 是对那个拷贝进行了+2，实际上并不起作用。如果需要起作用的话，那么我们需要把那个类型写成指针类型。为了类型匹配，调用的时候要加一个\u0026amp;符号。\n结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import \u0026#34;fmt\u0026#34; type user struct { name string password string } func main() { a := user{name: \u0026#34;wang\u0026#34;, password: \u0026#34;1024\u0026#34;} b := user{\u0026#34;wang\u0026#34;, \u0026#34;1024\u0026#34;} c := user{name: \u0026#34;wang\u0026#34;} c.password = \u0026#34;1024\u0026#34; var d user d.name = \u0026#34;wang\u0026#34; d.password = \u0026#34;1024\u0026#34; fmt.Println(a, b, c, d) // {wang 1024} {wang 1024} {wang 1024} {wang 1024} fmt.Println(checkPassword(a, \u0026#34;haha\u0026#34;)) // false fmt.Println(checkPassword2(\u0026amp;a, \u0026#34;haha\u0026#34;)) // false } func checkPassword(u user, password string) bool { return u.password == password } func checkPassword2(u *user, password string) bool { return u.password == password } 结构体是带类型的字段的集合。\n这里的 user 结构包含了两个字段 name 和 password，我们可以用结构体的名称去初始化一个结构体变量，构造的时候需要传入每个字段的初始值，也可以用键值对的方式去指定初始值，这样可以只对一部分字段进行初始化。结构体也支持指针，这种实现可以避免一些大结构体的拷贝开销。\n结构体方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; type user struct { name string password string } func (u user) checkPassword(password string) bool { return u.password == password } func (u *user) resetPassword(password string) { u.password = password } func main() { a := user{name: \u0026#34;wang\u0026#34;, password: \u0026#34;1024\u0026#34;} a.resetPassword(\u0026#34;2048\u0026#34;) fmt.Println(a.checkPassword(\u0026#34;2048\u0026#34;)) // true } 在 Go 语言中可以为结构体去定义一些方法，类似于其他语言里面的类成员函数。\n错误处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) type user struct { name string password string } func findUser(users []user, name string) (v *user, err error) { for _, u := range users { if u.name == name { return \u0026amp;u, nil } } return nil, errors.New(\u0026#34;not found\u0026#34;) } func main() { u, err := findUser([]user{{\u0026#34;wang\u0026#34;, \u0026#34;1024\u0026#34;}}, \u0026#34;wang\u0026#34;) if err != nil { fmt.Println(err) return } fmt.Println(u.name) // wang if u, err := findUser([]user{{\u0026#34;wang\u0026#34;, \u0026#34;1024\u0026#34;}}, \u0026#34;li\u0026#34;); err != nil { fmt.Println(err) // not found return } else { fmt.Println(u.name) } } 在 Go 语言中，常用的做法是使用了一个单独的返回值来传递错误信息。我们可以用简单的 if else 语句来处理错误。\n在函数里，我们可以在返回值类型里面加一个 error，就表示这个函数可能会返回错误。\n在函数实现的时候，return 需要同时 return 两个值，如果出现错误的话，那么会 return nil 和一个 error，如果没有错误的话，那么就返回原本的结果和 nil。\n字符串操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { a := \u0026#34;hello\u0026#34; fmt.Println(strings.Contains(a, \u0026#34;ll\u0026#34;)) // true fmt.Println(strings.Count(a, \u0026#34;l\u0026#34;)) // 2 fmt.Println(strings.HasPrefix(a, \u0026#34;he\u0026#34;)) // true fmt.Println(strings.HasSuffix(a, \u0026#34;llo\u0026#34;)) // true fmt.Println(strings.Index(a, \u0026#34;ll\u0026#34;)) // 2 fmt.Println(strings.Join([]string{\u0026#34;he\u0026#34;, \u0026#34;llo\u0026#34;}, \u0026#34;-\u0026#34;)) // he-llo fmt.Println(strings.Repeat(a, 2)) // hellohello fmt.Println(strings.Replace(a, \u0026#34;e\u0026#34;, \u0026#34;E\u0026#34;, -1)) // hEllo fmt.Println(strings.Split(\u0026#34;a-b-c\u0026#34;, \u0026#34;-\u0026#34;)) // [a b c] fmt.Println(strings.ToLower(a)) // hello fmt.Println(strings.ToUpper(a)) // HELLO fmt.Println(len(a)) // 5 b := \u0026#34;你好\u0026#34; fmt.Println(len(b)) // 6 } 在 Go 标准库的 strings 包中有很多常用的字符串工具函数比如 contains 判断一个字符串里面是否有包含另外一个字符串，count 字符串计数，index 查找某个字符串的位置，join 连接多个字符串，repeat 重复多个字符串，replace 替换字符串。\n字符串格式化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; type point struct { x, y int } func main() { s := \u0026#34;hello\u0026#34; n := 123 p := point{1, 2} fmt.Println(s, n) // hello 123 fmt.Println(p) // {1 2} fmt.Printf(\u0026#34;s=%v\\n\u0026#34;, s) // s=hello fmt.Printf(\u0026#34;n=%v\\n\u0026#34;, n) // n=123 fmt.Printf(\u0026#34;p=%v\\n\u0026#34;, p) // p={1 2} fmt.Printf(\u0026#34;p=%+v\\n\u0026#34;, p) // p={x:1 y:2} fmt.Printf(\u0026#34;p=%#v\\n\u0026#34;, p) // p=main.point{x:1, y:2} f := 3.141592653 fmt.Println(f) // 3.141592653 fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, f) // 3.14 } 在 Go 标准库的 fmt 包里有很多字符串格式相关的方法，比如 printf 类似于 C 语言中的 printf 函数，不同点在于 Go 语言中可以用%v 来打印任何类型的变量，不需要区分数字字符串。\nJSON 处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type userInfo struct { Name string Age int `json:\u0026#34;age\u0026#34;` Hobby []string } func main() { a := userInfo{Name: \u0026#34;wang\u0026#34;, Age: 18, Hobby: []string{\u0026#34;Golang\u0026#34;, \u0026#34;TypeScript\u0026#34;}} buf, err := json.Marshal(a) if err != nil { panic(err) } fmt.Println(buf) // [123 34 78 97...] fmt.Println(string(buf)) // {\u0026#34;Name\u0026#34;:\u0026#34;wang\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;Hobby\u0026#34;:[\u0026#34;Golang\u0026#34;,\u0026#34;TypeScript\u0026#34;]} buf, err = json.MarshalIndent(a, \u0026#34;\u0026#34;, \u0026#34;\\t\u0026#34;) if err != nil { panic(err) } fmt.Println(string(buf)) var b userInfo err = json.Unmarshal(buf, \u0026amp;b) if err != nil { panic(err) } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, b) // main.userInfo{Name:\u0026#34;wang\u0026#34;, Age:18, Hobby:[]string{\u0026#34;Golang\u0026#34;, \u0026#34;TypeScript\u0026#34;}} } 对于一个已有的结构体，我们可以什么都不做，只要保证每个字段的每一个字母是大写即公开字段，那么这个结构体就能用 JSON. marshaler 去序列化, 变成一个 json 的字符串。序列化之后字符上也可以用 JSON. unmarshaler 去反序列化到一个空的变量里面。\n时间处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { now := time.Now() fmt.Println(now) // 2022-03-27 18:04:59.433297 +0800 CST m=+0.000087933 t := time.Date(2022, 3, 27, 1, 25, 36, 0, time.UTC) t2 := time.Date(2022, 3, 27, 2, 30, 36, 0, time.UTC) fmt.Println(t) // 2022-03-27 01:25:36 +0000 UTC fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute()) // 2022 March 27 1 25 fmt.Println(t.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) // 2022-03-27 01:25:36 diff := t2.Sub(t) fmt.Println(diff) // 1h5m0s fmt.Println(diff.Minutes(), diff.Seconds()) // 65 3900 t3, err := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, \u0026#34;2022-03-27 01:25:36\u0026#34;) if err != nil { panic(err) } fmt.Println(t3 == t) // true fmt.Println(now.Unix()) // 1648738080 } Go 语言中最常用的就是 time. now () 获取当前时间，也可以用 time. date () 去构造一个带时区的时间，也可以用 sub 方法进行时间相减。\n数字解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { f, _ := strconv.ParseFloat(\u0026#34;1.234\u0026#34;, 64) fmt.Println(f) // 1.234 n, _ := strconv.ParseInt(\u0026#34;111\u0026#34;, 10, 64) fmt.Println(n) // 111 n, _ = strconv.ParseInt(\u0026#34;0x1000\u0026#34;, 0, 64) fmt.Println(n) // 4096 n2, _ := strconv.Atoi(\u0026#34;123\u0026#34;) fmt.Println(n2) // 123 n2, err := strconv.Atoi(\u0026#34;AAA\u0026#34;) fmt.Println(n2, err) // 0 strconv.Atoi: parsing \u0026#34;AAA\u0026#34;: invalid syntax } Go 语言中，字符串和数字类型的转换都在 strconv 包里。\n我们可以用 ParseInt 或 ParseFloat 来解析一个字符串。\n我们也可以用 Atoi 将十进制字符串转成数字，用 itoA 将数字转成字符串。\n进程信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { // go run example/20-env/main.go a b c d fmt.Println(os.Args) // [/var/folders/8p/n34xxfnx38dg8bv_x8l62t_m0000gn/T/go-build3406981276/b001/exe/main a b c d] fmt.Println(os.Getenv(\u0026#34;PATH\u0026#34;)) // /usr/local/go/bin... fmt.Println(os.Setenv(\u0026#34;AA\u0026#34;, \u0026#34;BB\u0026#34;)) buf, err := exec.Command(\u0026#34;grep\u0026#34;, \u0026#34;127.0.0.1\u0026#34;, \u0026#34;/etc/hosts\u0026#34;).CombinedOutput() if err != nil { panic(err) } fmt.Println(string(buf)) // 127.0.0.1 localhost } ","date":"2023-01-28T00:00:00Z","image":"https://ryanzuu.github.io/myblog/golang.jpg","permalink":"https://ryanzuu.github.io/myblog/p/go%E8%AF%AD%E8%A8%80%E4%B8%8A%E6%89%8B-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"Go语言上手-基础语法"},{"content":"基础认知 CSS 引入方式 引入方式 书写位置 作用范围 使用场景 内嵌式 CSS 写在 style 标签中 当前页面 小案例 外联式 CSS 写在单独的 css 文件中，通过 link 标签引入 多个页面 项目中 行内式 CSS 写在标签的 style 属性中 当前标签 配合 js 使用 基础选择器 标签选择器 结构：标签名{css 属性名：属性值；}\n作用：通过标签名，找到页面中所有这类标签，设置样式\n注意点：\n标签选择器选择的是一类标签，而不是单独某一个 标签选择器无论嵌套关系有多深，都能找到对应的标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 选择器 {} */ /* 标签选择器 就是 以标签名命名的选择器 */ p { color: red; } /* 标签选择器 选中所有的这个标签都生效css */ \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; 类选择器 结构：. 类名{css 属性名：属性值；}\n作用：通过类名，找到页面中所有带有这个类名标签，设置样式\n注意点：\n所有标签上都有 class 属性，class 属性的属性值称为类名 类名可以由数字、字母、下划线、中划线组成，但不能以数字或中划线开头 一个标签可以同时有多个类名，类名之间以空格隔开 类名可以重复，一个类选择器可以同时选中多个标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .red { color: red; } .size { font-size: 66px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 类: 定义 和 使用才能生效 --\u0026gt; \u0026lt;p\u0026gt;111\u0026lt;/p\u0026gt; \u0026lt;!-- 一个标签可以使用多个类名 , 需要空格隔开即可 --\u0026gt; \u0026lt;p class=\u0026#34;red size\u0026#34;\u0026gt;222\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;red\u0026#34;\u0026gt;这个标签文字也要变红\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; id 选择器 结构：** #id属性值 **{css 属性名：属性值；}\n作用：通过 id 属性值，找到页面中带有这个 id 属性值的标签，设置样式\n注意点：\n所有标签上都有 id 属性 id 属性值类似于身份证号码，在一个页面中是唯一的，不可重复的 一个标签上只能有一个 id 属性值 一个 id 选择器只能选中一个标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 定义id选择器 */ #blue { color: skyblue; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;blue\u0026#34;\u0026gt;这个div文字是蓝色的\u0026lt;/div\u0026gt; \u0026lt;p id=\u0026#34;blue\u0026#34;\u0026gt;111\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; 通配符选择器 结构：*****{css 属性名：属性值；}\n作用：找到页面中所有的标签，设置样式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;div\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;pppp\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;h1\u0026lt;/h1\u0026gt; \u0026lt;span\u0026gt;span\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt;pppp\u0026lt;/p\u0026gt; \u0026lt;h2\u0026gt;h2\u0026lt;/h2\u0026gt; \u0026lt;/body\u0026gt; 字体和文本样式 字体大小 属性名：font-size\n取值：数字+px\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; p { font-size: 30px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 默认字号是16 --\u0026gt; \u0026lt;p\u0026gt;段落文字\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; 字体粗细 属性名：font-weight\n取值：\n关键字\n正常 normal 加粗 bold 纯数字：100~900 的整百数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { /* 加粗 */ font-weight: 700; } h1 { /* 不加粗 */ font-weight: 400; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;这是div\u0026lt;/div\u0026gt; \u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; 字体样式（是否倾斜） 属性名：font-style\n取值：\n正常（默认值）：normal 倾斜：italic 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { /* 倾斜 */ font-style: italic; } em { /* 正常的, 不倾斜 */ font-style: normal; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;div文字\u0026lt;/div\u0026gt; \u0026lt;em\u0026gt;em\u0026lt;/em\u0026gt; \u0026lt;/body\u0026gt; 字体系列 font-family 属性名：font-family\n渲染规则：\n从左往右按顺序查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { /* font-family: 宋体; */ /* 如果用户电脑没有安装微软雅黑, 就按黑体显示文字 */ /* 如果电脑没有安装黑体, 就按任意一种非衬线字体系列显示 */ font-family: 微软雅黑, 黑体, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; 这是一个div标签 \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; p { /* font-size: ; font-style: ; font-weight: ; font-family: ; */ /* font: style weight size 字体; */ /* font: italic 700 66px 宋体; font-style: normal; */ font: 100px 微软雅黑; /* 一个属性冒号后面书写多个值的写法 -- 复合属性 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;这是p标签\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; 文本缩进 属性名：text-indent\n取值：\n数字+px 数字+em（推荐：1em=当前标签的 font-size 大小） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; p { /* text-indent: 50px; */ /* 首行缩进2个字的大小 */ /* 默认字号: 16px ; 32 */ /* text-indent: 40px; font-size: 20px; */ /* em: 一个字的大小 */ text-indent: 2em; font-size: 40px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;2019年，事件视界望远镜团队让世界首次看到了黑洞的样子。不过，研究人员公布的这张发光环形物体的图像并不是传统的图片，而是经过计算获得的。利用位于美国、墨西哥、智利、西班牙和南极地区的射电望远镜所得到的数据，研究人员进行了数学转换，最终合成了这张标志性的图片。研究团队还发布了实现这一壮举所用的编程代码，并撰文记录这一发现，其他研究者也可以在此基础上进一步加以分析。\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; 文本水平对齐方式 属性名：text-align\n取值：\n属性值 效果 left 左对齐 center 居中对齐 right 右对齐 注意点：\n如果需要让文本水平居中，text-align 属性给**文本所在标签（文本的父元素）**设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; h1 { /* text-align: left; */ /* text-align: right; */ text-align: center; } body { text-align: right; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;新闻标题\u0026lt;/h1\u0026gt; \u0026lt;img src=\u0026#34;./images/1.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; 文本修饰 属性名：text-decoration\n取值：\n属性值 效果 underline 下划线（常用） line-through 删除线（不常用） overline 上划线（几乎不用） none 无装饰线（常用） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { text-decoration: underline; } p { text-decoration: line-through; } h2 { text-decoration: overline; } a { text-decoration: none; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;div\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;ppp\u0026lt;/p\u0026gt; \u0026lt;h2\u0026gt;h2\u0026lt;/h2\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;我是超链接, 点呀\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; 行高 作用：控制一行的上下行间距\n属性名：line-height\n取值：\n数字+px 倍数（当前标签 font-size 的倍数） 应用：\n让单行文本垂直居中可以设置line-height：文字父元素高度 网页精准布局时，会设置line-height：1可以取消上下间距 行高与 font 连写的注意点：\n如果同时设置了行高和 font 连写，注意覆盖问题 font：style weight size/line-height family 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; p { /* line-height: 50px; */ /* 自己字号的1.5倍 */ /* line-height: 1.5; */ /* 66px 宋体 倾斜 加粗 行高是2倍 */ font: italic 700 66px/2 宋体; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;2019年，事件视界望远镜团队让世界首次看到了黑洞的样子。不过，研究人员公布的这张发光环形物体的图像并不是传统的图片，而是经过计算获得的。利用位于美国、墨西哥、智利、西班牙和南极地区的射电望远镜所得到的数据，研究人员进行了数学转换，最终合成了这张标志性的图片。研究团队还发布了实现这一壮举所用的编程代码，并撰文记录这一发现，其他研究者也可以在此基础上进一步加以分析\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; ","date":"2023-01-25T00:00:00Z","image":"https://ryanzuu.github.io/myblog/css.jpg","permalink":"https://ryanzuu.github.io/myblog/p/css%E5%9F%BA%E7%A1%80/","title":"CSS基础"}]